{"ast":null,"code":"import { useState, memo, useMemo, useEffect, Component } from 'react';\nimport { observe, unobserve, isObservable, raw, observable } from '@nx-js/observer-util';\nexport { unobserve as clearEffect } from '@nx-js/observer-util';\nimport { unstable_batchedUpdates } from './react-platform'; // it is window in the DOM and global in NodeJS and React Native\n\nconst isDOM = typeof window !== 'undefined';\nconst isNative = typeof global !== 'undefined';\nconst globalObj = isDOM ? window : isNative ? global : undefined;\nconst hasHooks = typeof useState === 'function';\nlet isInsideFunctionComponent = false;\nlet isInsideClassComponentRender = false;\nlet isInsideFunctionComponentWithoutHooks = false;\nconst COMPONENT = Symbol('owner component');\n\nfunction mapStateToStores(state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT];\n  return Object.keys(component).map(key => component[key]).filter(isObservable).map(raw);\n}\n\nfunction view(Comp) {\n  const isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);\n  let ReactiveComp;\n\n  if (isStatelessComp && hasHooks) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState(); // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n\n      const render = useMemo(() => observe(Comp, {\n        scheduler: () => setState({}),\n        lazy: true\n      }), // Adding the original Comp here is necessary to make React Hot Reload work\n      // it does not affect behavior otherwise\n      [Comp]); // cleanup the reactive connections after the very last render of the component\n\n      useEffect(() => {\n        return () => unobserve(render);\n      }, []); // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n\n      isInsideFunctionComponent = true;\n\n      try {\n        // run the reactive render instead of the original one\n        return render(props);\n      } finally {\n        isInsideFunctionComponent = false;\n      }\n    };\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp; // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n\n    class ReactiveClassComp extends BaseComp {\n      constructor(props, context) {\n        super(props, context);\n        this.state = this.state || {};\n        this.state[COMPONENT] = this; // create a reactive render for the component\n\n        this.render = observe(this.render, {\n          scheduler: () => this.setState({}),\n          lazy: true\n        });\n      }\n\n      render() {\n        isInsideClassComponentRender = !isStatelessComp;\n        isInsideFunctionComponentWithoutHooks = isStatelessComp;\n\n        try {\n          return isStatelessComp ? Comp(this.props, this.context) : super.render();\n        } finally {\n          isInsideClassComponentRender = false;\n          isInsideFunctionComponentWithoutHooks = false;\n        }\n      } // react should trigger updates on prop changes, while easyState handles store changes\n\n\n      shouldComponentUpdate(nextProps, nextState) {\n        const {\n          props,\n          state\n        } = this; // respect the case when the user defines a shouldComponentUpdate\n\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState);\n        } // return true if it is a reactive render or state changes\n\n\n        if (state !== nextState) {\n          return true;\n        } // the component should update if any of its props shallowly changed value\n\n\n        const keys = Object.keys(props);\n        const nextKeys = Object.keys(nextProps);\n        return nextKeys.length !== keys.length || nextKeys.some(key => props[key] !== nextProps[key]);\n      } // add a custom deriveStoresFromProps lifecyle method\n\n\n      static getDerivedStateFromProps(props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state);\n          super.deriveStoresFromProps(props, ...stores);\n        } // respect user defined getDerivedStateFromProps\n\n\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state);\n        }\n\n        return null;\n      }\n\n      componentWillUnmount() {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount();\n        } // clean up memory used by Easy State\n\n\n        unobserve(this.render);\n      }\n\n    }\n\n    ReactiveComp = ReactiveClassComp;\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name; // static props are inherited by class components,\n  // but have to be copied for function components\n\n  if (isStatelessComp) {\n    Object.keys(Comp).forEach(key => {\n      ReactiveComp[key] = Comp[key];\n    });\n  }\n\n  return isStatelessComp && hasHooks ? memo(ReactiveComp) : ReactiveComp;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst taskQueue = new Set();\nconst scheduler = {\n  isOn: false,\n\n  add(task) {\n    if (scheduler.isOn) {\n      taskQueue.add(task);\n    } else {\n      task();\n    }\n  },\n\n  flush() {\n    taskQueue.forEach(task => task());\n    taskQueue.clear();\n  },\n\n  on() {\n    scheduler.isOn = true;\n  },\n\n  off() {\n    scheduler.isOn = false;\n  }\n\n}; // until the function is finished running\n// react renders are batched by unstable_batchedUpdates\n// autoEffects and other custom reactions are batched by our scheduler\n\nfunction batch(fn, ctx, args) {\n  // do not apply scheduler logic if it is already applied from a parent function\n  // it would flush in the middle of the parent's batch\n  if (scheduler.isOn) {\n    return unstable_batchedUpdates(() => fn.apply(ctx, args));\n  }\n\n  try {\n    scheduler.on();\n    return unstable_batchedUpdates(() => fn.apply(ctx, args));\n  } finally {\n    scheduler.flush();\n    scheduler.off();\n  }\n} // this creates and returns a batched version of the passed function\n// the cache is necessary to always map the same thing to the same function\n// which makes sure that addEventListener/removeEventListener pairs don't break\n\n\nconst cache = new WeakMap();\n\nfunction batchFn(fn) {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  let batched = cache.get(fn);\n\n  if (!batched) {\n    batched = new Proxy(fn, {\n      apply(target, thisArg, args) {\n        return batch(target, thisArg, args);\n      }\n\n    });\n    cache.set(fn, batched);\n  }\n\n  return batched;\n}\n\nfunction batchMethodCallbacks(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n\n  if (descriptor && descriptor.writable && typeof descriptor.value === 'function') {\n    obj[method] = new Proxy(descriptor.value, {\n      apply(target, ctx, args) {\n        return Reflect.apply(target, ctx, args.map(batchFn));\n      }\n\n    });\n  }\n} // batched obj.addEventListener(cb) like callbacks\n\n\nfunction batchMethodsCallbacks(obj, methods) {\n  methods.forEach(method => batchMethodCallbacks(obj, method));\n}\n\nfunction batchMethod(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n\n  if (!descriptor) {\n    return;\n  }\n\n  const {\n    value,\n    writable,\n    set,\n    configurable\n  } = descriptor;\n\n  if (configurable && typeof set === 'function') {\n    Object.defineProperty(obj, method, _objectSpread2({}, descriptor, {\n      set: batchFn(set)\n    }));\n  } else if (writable && typeof value === 'function') {\n    obj[method] = batchFn(value);\n  }\n} // batches obj.onevent = fn like calls and store methods\n\n\nfunction batchMethods(obj, methods) {\n  methods = methods || Object.getOwnPropertyNames(obj);\n  methods.forEach(method => batchMethod(obj, method));\n  return obj;\n} // do a sync batching for the most common task sources\n// this should be removed when React's own batching is improved in the future\n// batch timer functions\n\n\nbatchMethodsCallbacks(globalObj, ['setTimeout', 'setInterval', 'requestAnimationFrame', 'requestIdleCallback']);\n\nif (globalObj.Promise) {\n  batchMethodsCallbacks(Promise.prototype, ['then', 'catch']);\n} // Event listener batching causes an input caret jumping bug:\n// https://github.com/RisingStack/react-easy-state/issues/92.\n// This part has to be commented out to prevent that bug.\n// React batches setStates in its event listeners anyways\n// so this commenting this part out is not a huge issue.\n// batch addEventListener calls\n\n/* if (globalObj.EventTarget) {\n  batchMethodsCallbacks(EventTarget.prototype, [\n    'addEventListener',\n    'removeEventListener',\n  ]);\n} */\n// this batches websocket event handlers\n\n\nif (globalObj.WebSocket) {\n  batchMethods(WebSocket.prototype, ['onopen', 'onmessage', 'onerror', 'onclose']);\n} // HTTP event handlers are usually wrapped by Promises, which is covered above\n\n\nfunction createStore(obj) {\n  return batchMethods(observable(typeof obj === 'function' ? obj() : obj));\n}\n\nfunction store(obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (isInsideFunctionComponent) {\n    // useMemo is not a semantic guarantee\n    // In the future, React may choose to “forget” some previously memoized values and recalculate them on next render\n    // see this docs for more explanation: https://reactjs.org/docs/hooks-reference.html#usememo\n    return useMemo(() => createStore(obj), []);\n  }\n\n  if (isInsideFunctionComponentWithoutHooks) {\n    throw new Error('You cannot use state inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.');\n  }\n\n  if (isInsideClassComponentRender) {\n    throw new Error('You cannot use state inside a render of a class component. Please create your store outside of the render function.');\n  }\n\n  return createStore(obj);\n}\n\nfunction autoEffect(fn, deps = []) {\n  if (isInsideFunctionComponent) {\n    return useEffect(() => {\n      const observer = observe(fn, {\n        scheduler: () => scheduler.add(observer)\n      });\n      return () => unobserve(observer);\n    }, deps);\n  }\n\n  if (isInsideFunctionComponentWithoutHooks) {\n    throw new Error('You cannot use autoEffect inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.');\n  }\n\n  if (isInsideClassComponentRender) {\n    throw new Error('You cannot use autoEffect inside a render of a class component. Please use it in the constructor or lifecycle methods instead.');\n  }\n\n  const observer = observe(fn, {\n    scheduler: () => scheduler.add(observer)\n  });\n  return observer;\n}\n\nexport { autoEffect, batch, store, view };","map":{"version":3,"sources":["../src/utils.js","../src/view.js","../src/scheduler.js","../src/batch.js","../src/store.js","../src/autoEffect.js"],"names":["isDOM","isNative","globalObj","hasHooks","isInsideFunctionComponent","isInsideClassComponentRender","isInsideFunctionComponentWithoutHooks","COMPONENT","Symbol","component","state","Object","key","isStatelessComp","Comp","ReactiveComp","props","useState","render","useMemo","observe","scheduler","setState","lazy","useEffect","unobserve","BaseComp","constructor","shouldComponentUpdate","keys","nextKeys","nextProps","stores","mapStateToStores","componentWillUnmount","memo","taskQueue","isOn","add","task","flush","on","off","unstable_batchedUpdates","fn","cache","batched","apply","batch","descriptor","obj","Reflect","args","methods","method","batchMethodCallbacks","configurable","set","batchFn","writable","batchMethod","batchMethodsCallbacks","Promise","batchMethods","WebSocket","observable","createStore","deps","observer"],"mappings":"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","sourcesContent":["import { useState } from 'react';\n\n// try to find the global object\n// it is window in the DOM and global in NodeJS and React Native\nconst isDOM = typeof window !== 'undefined';\nconst isNative = typeof global !== 'undefined';\nexport const globalObj = isDOM\n  ? window\n  : isNative\n  ? global\n  : undefined;\n\nexport const hasHooks = typeof useState === 'function';\n","import { Component, useState, useEffect, useMemo, memo } from 'react';\nimport {\n  observe,\n  unobserve,\n  raw,\n  isObservable,\n} from '@nx-js/observer-util';\n\nimport { hasHooks } from './utils';\n\nexport let isInsideFunctionComponent = false;\nexport let isInsideClassComponentRender = false;\nexport let isInsideFunctionComponentWithoutHooks = false;\nconst COMPONENT = Symbol('owner component');\n\nfunction mapStateToStores(state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT];\n  return Object.keys(component)\n    .map(key => component[key])\n    .filter(isObservable)\n    .map(raw);\n}\n\nexport function view(Comp) {\n  const isStatelessComp = !(\n    Comp.prototype && Comp.prototype.isReactComponent\n  );\n\n  let ReactiveComp;\n\n  if (isStatelessComp && hasHooks) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState();\n      // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n      const render = useMemo(\n        () =>\n          observe(Comp, {\n            scheduler: () => setState({}),\n            lazy: true,\n          }),\n        // Adding the original Comp here is necessary to make React Hot Reload work\n        // it does not affect behavior otherwise\n        [Comp],\n      );\n\n      // cleanup the reactive connections after the very last render of the component\n      useEffect(() => {\n        return () => unobserve(render);\n      }, []);\n\n      // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n      isInsideFunctionComponent = true;\n      try {\n        // run the reactive render instead of the original one\n        return render(props);\n      } finally {\n        isInsideFunctionComponent = false;\n      }\n    };\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp;\n    // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n    class ReactiveClassComp extends BaseComp {\n      constructor(props, context) {\n        super(props, context);\n\n        this.state = this.state || {};\n        this.state[COMPONENT] = this;\n\n        // create a reactive render for the component\n        this.render = observe(this.render, {\n          scheduler: () => this.setState({}),\n          lazy: true,\n        });\n      }\n\n      render() {\n        isInsideClassComponentRender = !isStatelessComp;\n        isInsideFunctionComponentWithoutHooks = isStatelessComp;\n        try {\n          return isStatelessComp\n            ? Comp(this.props, this.context)\n            : super.render();\n        } finally {\n          isInsideClassComponentRender = false;\n          isInsideFunctionComponentWithoutHooks = false;\n        }\n      }\n\n      // react should trigger updates on prop changes, while easyState handles store changes\n      shouldComponentUpdate(nextProps, nextState) {\n        const { props, state } = this;\n\n        // respect the case when the user defines a shouldComponentUpdate\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState);\n        }\n\n        // return true if it is a reactive render or state changes\n        if (state !== nextState) {\n          return true;\n        }\n\n        // the component should update if any of its props shallowly changed value\n        const keys = Object.keys(props);\n        const nextKeys = Object.keys(nextProps);\n        return (\n          nextKeys.length !== keys.length ||\n          nextKeys.some(key => props[key] !== nextProps[key])\n        );\n      }\n\n      // add a custom deriveStoresFromProps lifecyle method\n      static getDerivedStateFromProps(props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state);\n          super.deriveStoresFromProps(props, ...stores);\n        }\n        // respect user defined getDerivedStateFromProps\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state);\n        }\n        return null;\n      }\n\n      componentWillUnmount() {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount();\n        }\n        // clean up memory used by Easy State\n        unobserve(this.render);\n      }\n    }\n\n    ReactiveComp = ReactiveClassComp;\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name;\n  // static props are inherited by class components,\n  // but have to be copied for function components\n  if (isStatelessComp) {\n    Object.keys(Comp).forEach(key => {\n      ReactiveComp[key] = Comp[key];\n    });\n  }\n\n  return isStatelessComp && hasHooks\n    ? memo(ReactiveComp)\n    : ReactiveComp;\n}\n","const taskQueue = new Set();\n\nconst scheduler = {\n  isOn: false,\n  add(task) {\n    if (scheduler.isOn) {\n      taskQueue.add(task);\n    } else {\n      task();\n    }\n  },\n  flush() {\n    taskQueue.forEach(task => task());\n    taskQueue.clear();\n  },\n  on() {\n    scheduler.isOn = true;\n  },\n  off() {\n    scheduler.isOn = false;\n  },\n};\n\nexport default scheduler;\n","/* eslint camelcase: 0 */\n\n// react-platform is set to either react-dom or react-native during test and execution\n// eslint-disable-next-line import/no-unresolved\nimport { unstable_batchedUpdates } from 'react-platform';\nimport { globalObj } from './utils';\nimport scheduler from './scheduler';\n\n// this runs the passed function and delays all re-renders\n// until the function is finished running\n// react renders are batched by unstable_batchedUpdates\n// autoEffects and other custom reactions are batched by our scheduler\nexport function batch(fn, ctx, args) {\n  // do not apply scheduler logic if it is already applied from a parent function\n  // it would flush in the middle of the parent's batch\n  if (scheduler.isOn) {\n    return unstable_batchedUpdates(() => fn.apply(ctx, args));\n  }\n  try {\n    scheduler.on();\n    return unstable_batchedUpdates(() => fn.apply(ctx, args));\n  } finally {\n    scheduler.flush();\n    scheduler.off();\n  }\n}\n\n// this creates and returns a batched version of the passed function\n// the cache is necessary to always map the same thing to the same function\n// which makes sure that addEventListener/removeEventListener pairs don't break\nconst cache = new WeakMap();\nfunction batchFn(fn) {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n  let batched = cache.get(fn);\n  if (!batched) {\n    batched = new Proxy(fn, {\n      apply(target, thisArg, args) {\n        return batch(target, thisArg, args);\n      },\n    });\n    cache.set(fn, batched);\n  }\n  return batched;\n}\n\nfunction batchMethodCallbacks(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n  if (\n    descriptor &&\n    descriptor.writable &&\n    typeof descriptor.value === 'function'\n  ) {\n    obj[method] = new Proxy(descriptor.value, {\n      apply(target, ctx, args) {\n        return Reflect.apply(target, ctx, args.map(batchFn));\n      },\n    });\n  }\n}\n\n// batched obj.addEventListener(cb) like callbacks\nfunction batchMethodsCallbacks(obj, methods) {\n  methods.forEach(method => batchMethodCallbacks(obj, method));\n}\n\nfunction batchMethod(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n  if (!descriptor) {\n    return;\n  }\n  const { value, writable, set, configurable } = descriptor;\n\n  if (configurable && typeof set === 'function') {\n    Object.defineProperty(obj, method, {\n      ...descriptor,\n      set: batchFn(set),\n    });\n  } else if (writable && typeof value === 'function') {\n    obj[method] = batchFn(value);\n  }\n}\n\n// batches obj.onevent = fn like calls and store methods\nexport function batchMethods(obj, methods) {\n  methods = methods || Object.getOwnPropertyNames(obj);\n  methods.forEach(method => batchMethod(obj, method));\n  return obj;\n}\n\n// do a sync batching for the most common task sources\n// this should be removed when React's own batching is improved in the future\n\n// batch timer functions\nbatchMethodsCallbacks(globalObj, [\n  'setTimeout',\n  'setInterval',\n  'requestAnimationFrame',\n  'requestIdleCallback',\n]);\n\nif (globalObj.Promise) {\n  batchMethodsCallbacks(Promise.prototype, ['then', 'catch']);\n}\n\n// Event listener batching causes an input caret jumping bug:\n// https://github.com/RisingStack/react-easy-state/issues/92.\n// This part has to be commented out to prevent that bug.\n// React batches setStates in its event listeners anyways\n// so this commenting this part out is not a huge issue.\n\n// batch addEventListener calls\n/* if (globalObj.EventTarget) {\n  batchMethodsCallbacks(EventTarget.prototype, [\n    'addEventListener',\n    'removeEventListener',\n  ]);\n} */\n\n// this batches websocket event handlers\nif (globalObj.WebSocket) {\n  batchMethods(WebSocket.prototype, [\n    'onopen',\n    'onmessage',\n    'onerror',\n    'onclose',\n  ]);\n}\n\n// HTTP event handlers are usually wrapped by Promises, which is covered above\n","import { useMemo } from 'react';\nimport { observable } from '@nx-js/observer-util';\n\nimport { batchMethods } from './batch';\nimport {\n  isInsideFunctionComponent,\n  isInsideClassComponentRender,\n  isInsideFunctionComponentWithoutHooks,\n} from './view';\n\nfunction createStore(obj) {\n  return batchMethods(\n    observable(typeof obj === 'function' ? obj() : obj),\n  );\n}\n\nexport function store(obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (isInsideFunctionComponent) {\n    // useMemo is not a semantic guarantee\n    // In the future, React may choose to “forget” some previously memoized values and recalculate them on next render\n    // see this docs for more explanation: https://reactjs.org/docs/hooks-reference.html#usememo\n    return useMemo(() => createStore(obj), []);\n  }\n  if (isInsideFunctionComponentWithoutHooks) {\n    throw new Error(\n      'You cannot use state inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.',\n    );\n  }\n  if (isInsideClassComponentRender) {\n    throw new Error(\n      'You cannot use state inside a render of a class component. Please create your store outside of the render function.',\n    );\n  }\n  return createStore(obj);\n}\n","import { useEffect } from 'react';\nimport { observe, unobserve } from '@nx-js/observer-util';\nimport scheduler from './scheduler';\n\nimport {\n  isInsideFunctionComponent,\n  isInsideClassComponentRender,\n  isInsideFunctionComponentWithoutHooks,\n} from './view';\n\nexport function autoEffect(fn, deps = []) {\n  if (isInsideFunctionComponent) {\n    return useEffect(() => {\n      const observer = observe(fn, {\n        scheduler: () => scheduler.add(observer),\n      });\n      return () => unobserve(observer);\n    }, deps);\n  }\n  if (isInsideFunctionComponentWithoutHooks) {\n    throw new Error(\n      'You cannot use autoEffect inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.',\n    );\n  }\n  if (isInsideClassComponentRender) {\n    throw new Error(\n      'You cannot use autoEffect inside a render of a class component. Please use it in the constructor or lifecycle methods instead.',\n    );\n  }\n\n  const observer = observe(fn, {\n    scheduler: () => scheduler.add(observer),\n  });\n  return observer;\n}\n\nexport { unobserve as clearEffect };\n"]},"metadata":{},"sourceType":"module"}